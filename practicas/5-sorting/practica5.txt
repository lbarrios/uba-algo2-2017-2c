Ejercicio 1) Comparar la complejidad de los algoritmos de ordenamiento dados en la teórica para el caso en que el arreglo a ordenar se encuentre perfectamente ordenado de manera inversa a la deseada.

Insertion Sort: O(n^2)
Tree Sort: O(n logn)

Selection Sort: O(n^2)
Heap Sort: O(n logn)

Merge Sort: O(n logn)
Quick Sort: O(n logn)

Ejercicio 2) Imagine secuencias de naturales de la forma s = Concatenar (s', s''), donde s' es una secuencia ordenada de naturales y s'' es una secuencia de naturales elegidos al azar. Qué método utilizaría para ordenar s? Justificar. (Entiéndase que s' se encuentra ordenada de la manera deseada.)

Puedo ordenar la secuencia s'', con cualquier algoritmo eficiente (ej quicksort, heapsort, treesort) y luego mergear ambas partes en O(n). El costo total de hacer esto sería O("ordenar s''") + O("largo de s").

Ejercicio 3) Escribir un algoritmo que encuentre los k elementos más chicos de un arreglo de dimensión n, donde k ≤ n. ¿Cuál es su complejidad temporal? ¿A partir de qué valor de k es ventajoso ordenar el arreglo entero primero?

input: A arreglo de dimensión n

resultado = list // En B van a estar los resultados
min_heapify(A) // min-heapify in-place sobre A
for(i=0; i<k; i++){
	append(B, extract-min(A));
}

Ejercicio 4) Se tiene un conjunto de n secuencias {s_1, s_2, ... , s_n} en donde cada s_i (1 ≤ i ≤ n) es una secuencia ordenada de naturales. ¿Qué método utilizaría para obtener un arreglo que contenga todos los elementos de la unión de los s_i ordenados. Describirlo. Justificar.

0) Creo un arreglo vacío de tamaño igual a la suma de los tamaños de las secuencias (llamemos a este tamaño K).

1) Formo las tuplas T_i = (f_i, i, *s_i), en donde f_i es el primer elemento de s_i, para cada s_i (1 ≤ i ≤ n). Esto lo hago en O(n). Es claro que hay un orden estricto entre las distintas T_i, ya que aún suponiendo que todos los f_i sean iguales, cada T_i va a corresponderse a un índice i distinto.

2) Armo un heap con estas tuplas en O(n log n). Particularmente, el primer elemento del heap siempre va a tener al siguiente elemento que voy a agregar a la secuencia (pues dado que las secuencias están ordenadas, voy a querer agregar el menor/mayor de entre los primeros elementos de todas las secuencias.)

3) Mientras existan elementos en el heap, realizo:
	3.a) Hago pop() del primer elemento. O(log n)
	3.b) Inserto el f_i correspondiente en el array. O(1)
	3.c) Avanzo la secuencia s_i correspondiente, y si aún quedan elementos en ella, genero una nueva tupla T_i' = (f_i', i, *s_i), tal que f_i' es el siguiente elemento de s_i (es decir, al que acabo de avanzar). En caso de que la secuencia s_i haya quedado vacía, salteo el siguiente paso. O(1)
	3.d) Inserto la tupla T_i' en el heap. O(log n)

4) En total, voy a insertar todos los elementos de todas las secuencias, es decir K elementos, y cada paso me va a costar O(log n). El algoritmo va a tener una complejidad de O(K * log n).


Ejercicio 5) Se tiene un arreglo de n números naturales que se quiere ordenar por frecuencia, y en caso de igual frecuencia, por su valor. Por ejemplo, a partir del arreglo [1, 3, 1, 7, 2, 7, 1, 7, 3] se quiere obtener [1, 1, 1, 7, 7, 7, 3, 3, 2]. Describa un algoritmo que realice el ordenamiento descrito, utilizando las estructuras de datos intermedias que considere necesarias. Calcule el orden de complejidad temporal del algoritmo propuesto.

1) Ordeno el arreglo A en O(n log n) utilizando cualquier algoritmo de sorting eficiente (ej heap sort).

Ejemplo, dado A = [1, 3, 1, 7, 2, 7, 1, 7, 3], el resultado es A = [1, 1, 1, 2, 3, 3, 7, 7, 7]

2) Genero un arreglo cantidades de tamaño máximo n, que va a tener tuplas (c_i, n_i), en donde n_i es un núḿero y c_i es la cantidad de veces que aparece.

3) Itero sobre el arreglo A con dos índices i1, i2, en donde voy a ir avanzando i2 hasta encontrar un número distinto a i1, y luego comenzando con i1=i2, definiendo intervalos para cada número, contando la cantidad de apariciones de cada uno como la resta entre ambos índices. Ejemplo, en A:
	* comienzo con i2=i1=k=0.
	* mientras i2 != largo(A)
		* mientras A[i2] == A[i1]: i2++
		* cantidades[k] = i2-i1 = 3
		* k++

Usando A, el arreglo me quedaría al final cantidades = [(3,1), (1,2), (2,3), (3,7)]

4) Al final del punto anterior, voy a tener un arreglo en donde voy a tener tuplas con la frecuencia correspondiente para cada elemento. Ordeno este array en O(n log n) utilizando cualquier algoritmo de sorting eficiente (ej, heap sort). Defino la comparación de dos tuplas como T_a < T_b ssi { (T_a[0] > T_b[0]) or (T_a[0] == T_b[0] and T_a[1] < T_b[1]) }. Usando el ejemplo, el arreglo me quedaría ordenado así:
cantidades = [(3,1), (3,7), (2,3), (1,2)]

5) Escribo sobre A el resultado, que sería iterar sobre cantidades y escribir la cantidad de elementos correspondiente en el orden en que se encuentran allí. En el ejemplo, esto sería, tres 1, tres 7, dos 3, y un 2. Me quedaría A=[1, 1, 1, 7, 7, 7, 3, 3, 2].